import { ZegoDataReport } from '../common/zego.datareport';
import { VideoInfo, AudioMixConfig, ERRO, PublishOption } from '../common/zego.entity';
import { ZegoSignal } from '../common/zego.signal';
import { Logger } from '../common/zego.logger';
import { AudioMixUtil } from '../util/AudioMixUtil';
import { ZegoHTMLAudioElement, ZegoVideoDecodeType } from '../../types/index';
import { PitchUtil } from '../util/pitchUtil';
import { LoggerWeb } from './zego.logger.webrtc';
export declare class ZegoPublish {
    logger: Logger;
    signal: any;
    state: number;
    sessionId: number;
    waitingICETimeInterval: number;
    waitingAnswerTimeInterval: number;
    candidateInfo: never[];
    waitingICETimer: any;
    waitingAnswerTimer: any;
    qualityTimer: any;
    qualityTimeInterval: number;
    publishQualityList: never[];
    maxQualityListCount: number;
    lastPublishStats: any;
    reportSeq: number;
    dataReport: ZegoDataReport;
    qualityUpload: boolean;
    qualityUploadInterval: number;
    qualityUploadLastTime: number;
    qualitySeq: number;
    maxRetryCount: number;
    currentRetryCount: number;
    retryState: number;
    waitingServerTimerInterval: number;
    waitingServerTimer: number | null;
    videoInfo: VideoInfo;
    offerSeq: number;
    streamId: string | null;
    localStream: MediaStream;
    audioMixing: AudioMixUtil;
    sessionSeq: number;
    peerConnection: RTCPeerConnection | any;
    qualityCount: number;
    closeSessionSignal: boolean;
    micTrack: MediaStreamTrack | null;
    pitchEffect: PitchUtil;
    audioBitRate: number;
    localSdpRevert: boolean;
    videoDecodeType: ZegoVideoDecodeType;
    constructor(log: LoggerWeb, signal: ZegoSignal | null, dataReport: ZegoDataReport, qualityTimeInterval: number);
    private publishStateUpdateError;
    private resetPublish;
    private clearTryPublishTimer;
    private clearPublishQualityTimer;
    private shouldSendCloseSession;
    startPublish(streamId: string, localStream: MediaStream, videoInfo: VideoInfo, publishOption?: PublishOption): void;
    onCreatePublishSessionSuccess(data: {
        session_id?: string | number;
        result?: string | number;
        turn_server?: any;
        stun_server?: any;
        turn_username?: any;
        turn_auth_key?: any;
    }): void;
    onCreateOfferSuccess(desc: {
        sdp: any;
    }): void;
    updateBandwidthRestriction(sdp: any, bandwidth: string | number): any;
    onSetLocalDescriptionSuccess(desc: {
        sdp: any;
    }): void;
    onRecvMediaDescription(seq: number, sessionId: number, data: any): void;
    onGetRemoteOfferSucceses(desc: string): void;
    onIceConnectionStateChange(event: any): void;
    onIceCandidate(event: any): void;
    sendCandidateInfo(candidateInfo: any[]): void;
    onConnectionStateChange(event: {
        target: {
            signalingState: string;
        };
    }): void;
    onRecvCandidateInfo(seq: number, sessionId: number, data: any): void;
    onRecvCloseSession(seq: number, sessionId: number, data: any): void;
    onRecvResetSession(seq: number, sessionId: number, data: any): void;
    shouldRetryPublish(): boolean;
    startRetryPublish(): void;
    tryStartPublish(streamId: string | null): void;
    checkPublishConnectionFailedState(connectionState: string): void;
    setPublishQualityTimer(): void;
    getPublishStats(results: {
        forEach: (arg0: (result: any) => void) => void;
    }): void;
    uploadPublishQuality(publishData: any): void;
    stopPublish(): void;
    onPublishStateUpdate(type: number, streamId: string | null, error?: ERRO | undefined): void;
    onPublishQualityUpdate(streamId: string | null, quality: any): void;
    onDisconnect(): void;
    playEffect(AudioMixConfig: AudioMixConfig, audioBuffer: AudioBuffer, start?: Function, end?: Function): void;
    pauseEffect(): void;
    resumeEffect(): void;
    startMixingAudio(audio: ZegoHTMLAudioElement, replace: boolean): boolean;
    stopMixingAudio(): boolean;
    voiceChange(mult: number): false | undefined;
    voiceBack(): void;
}
